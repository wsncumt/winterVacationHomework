\documentclass[30pt]{article}
\usepackage[space,fancyhdr,fntef]{ctexcap}
\usepackage{fontspec}
\fontspec{宋体}
\setmainfont{Times New Roman}
%\fontsize{50pt}{50pt}\selectfont
\renewcommand{\rmdefault}{ptm}
\usepackage[namelimits,sumlimits,nointlimits]{amsmath}
\usepackage[bottom=20mm,top=30mm,left=25mm,right=25mm,centering]{geometry}
\usepackage{color}
\usepackage{CJKfntef}%下划线宏包160页
\usepackage{xcolor}
\usepackage{arydshln}%234页，虚线表格宏包
\pagestyle{fancy} \fancyhf{}
\fancyhead[OL]{\color{gray}~~~班序号：Java41班 \hfill 姓名：王松年~~~}
\fancyfoot[C]{\color{gray}\thepage}
%\renewcommand{\footrulewidth}{0.4pt}%改为0pt即可去掉页脚上面的横线
%\usepackage{parskip}
%\usepackage{indentfirst}
\usepackage{graphicx}%插图宏包，参见手册318页
\definecolor{dkgreen}{RGB}{106,135,89}
\definecolor{dkblue}{RGB}{103,150,163}
\definecolor{wgray}{RGB}{248,248,248}
\usepackage{listings}
\lstset{language=Java,
backgroundcolor=\color{wgray},
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色
%lablestep=1,
%lablesep=5pt,
%lablestyle=\tiny,
%tablesize=4,
%captionpos=b,
basicstyle=\ttfamily\small,
keywordstyle=\color{orange},
commentstyle=\color{gray},
stringstyle=\color{dkgreen},
numberstyle=\tiny,
numbersep=8pt,
frame=single,%topline.bottomline,lines,single,leftline
identifierstyle=\color{dkblue},
numbers=left,
stepnumber=1,
xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
breaklines=true,
showstringspaces=true
}
\usepackage[xetex,colorlinks]{hyperref}%394页  \href{网址}{文本}
\hypersetup{urlcolor=blue}
%\linebreak[2]%换行，152页
\usepackage{fancybox}%盒子宏包55页

\begin{document}

\newcommand{\dm}[1]{\colorbox{wgray}{\lstinline^#1^}}
\newcommand{\myroman}[1]{\uppercase\expandafter{\romannumeral#1}}
\newcounter{num}[section] \renewcommand{\thenum}{\arabic{num}.} \newcommand{\num}{\refstepcounter{num}\text{\thenum}}
%\newlength{\mylen}
%\settowidth{\mylen}{Tips}
%\settoheight{\myheight}{T}
\newenvironment{tips}{\kaishu\zihao{-6}\color{blue}{\noindent\rule[-3pt]{\textwidth}{0.5pt}\par \em \noindent {\zihao{-5} \textcolor[rgb]{1.00,0.00,0.00}{Tips}}}\par}{\\ \rule[3mm]{\textwidth}{0.5pt}\par}

\newenvironment{jie}{\kaishu\zihao{-5}\color{blue}{\noindent\em 解：}\par}{\hfill $\diamondsuit$\par}

%\begin{lstlisting}
%1
%\end{lstlisting}

%
%\newlength{\mylen}
%\settowidth{\mylen}{For iasasasaasasaasdadadsadasd =10}
%\makebox[0pt][l]%55页
%{
%\color{wgray}\rule[0pt]{\mylen}{5pt}%59页
%}


%\lstinline[参数]符号 源程序 符号。
\CTEXsetup[name={Day~,}]{section}

%\href{https://www.baidu.com/?tn=40020637_11_oem_dg}{百度}

%\rule[1.3mm]{1cm}{1pt}tips\rule[2.5mm]{1cm}{1pt}
%
%
%\begin{tips}
%123
%\end{tips}


\section{}%day1
\num 如果\dm{int x=20, y=5},则语句\dm{System.out.println(x+y + "" +(x+y)+y);}的输出结果是（~~~\textcolor[rgb]{1.00,0.00,0.00}{D}~~~）。

A.\dm{2530} \hspace{2.5cm} B.\dm{55} \hspace{2.5cm} C.\dm{2052055}\hspace{2.5cm} D.\dm{25255}

\begin{jie}
先计算\dm{()}里的：x + y = 25.

从左向右计算：\dm{x + y} 为\dm{25}，遇到字符串将数字转为字符串，然后将后边的续接到前边：25255.
\end{jie}

\num 在Java中，在同一包内，类Cat里面有个公共方法sleep()，该方法前有static修饰，则可以直接用Cat.sleep()。（~~~\textcolor[rgb]{1.00,0.00,0.00}{A}~~~）

A.\dm{正确} \hspace{2.5cm} B.\dm{错误} \hfill \hphantom{C.\dm{205255}}\hfill\hphantom{D.\dm{25255}}\hfill \hphantom{~}

\begin{tips}
用\dm{static}修饰的为类方法，类方法可由类名直接调用。
\end{tips}

\num 给定以下方法声明，调用执行\dm{mystery(1234)}的输出结果是（~~~\textcolor[rgb]{1.00,0.00,0.00}{B}~~~）。

\begin{lstlisting}
//precondition: x >= 0
public void mystery (int x) {
    System.out.print(x % 10);
    if ((x / 10) != 0){
        mystery(x / 10);
    }
    System.out.print(x % 10);
}
\end{lstlisting}

A.\dm{1441} \hspace{2.42cm} B.\dm{43211234} \hspace{1.5cm} C.\dm{3443}\hspace{3cm} D.\dm{12344321}

\begin{jie}
x\%10 = 1234 \% 10 = \textcolor[rgb]{1.00,0.00,0.00}{4}
\end{jie}
\begin{tips}
该方法的第3$\sim$6行的功能是实现逆序打印。
\end{tips}

\num 实现函数\dm{ToLowerCase()}，该函数接收一个字符串参数\dm{str},并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。\href{https://leetcode-cn.com/problems/to-lower-case/\%20--with-chrome-plus-plus\%20--disable-features=RendererCodeIntegrity,FlashDeprecationWarning/}{OJ链接-转换成小写字母}

\begin{lstlisting}[title= 转换成小写字母]
class Solution {
    public String toLowerCase(String str) {
        return str.toLowerCase();
    }
}
\end{lstlisting}

\begin{tips}
转大写：\dm{str.toUpperCase()}

转小写：\dm{str.toLowerCase()}
\end{tips}

\num 给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。\href{https://leetcode-cn.com/problems/rotate-array/\%20--with-chrome-plus-plus\%20--disable-features=RendererCodeIntegrity,FlashDeprecationWarning/} {OJ链接-旋转数组}

\begin{lstlisting}[title = 旋转数组]
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);

    }
    public void reverse(int[] nums,int lo,int hi){
        while(lo < hi){
            int tmp = nums[lo];
            nums[lo] = nums[hi];
            nums[hi] = tmp;
            lo++;
            hi--;
        }
    }
}
\end{lstlisting}

\begin{tips}
在C语言做过这个题。

1.要先把旋转的位置除数组的长度取余，因为向右移动数组长度个位置（或其倍数）等于没有移动。

2.把整个数组旋转得到新的数组。

3.依次旋转数组的前\dm{k}个元素（\dm{0到k-1}），和后边剩余的元素。
\end{tips}
\newpage
\section{}%day2
\num 如果类的方法没有返回值，该方法的返回类型是（~~~\textcolor[rgb]{1.00,0.00,0.00}{A}~~~）。

A.\dm{void}\hfill B.\dm{null} \hfill C.\dm{abstract}\hfill D.\dm{default}

\num \dm{Java Application(Java应用程序)}源程序文件编译后的字节码文件的拓展名是（~~~\textcolor[rgb]{1.00,0.00,0.00}{B}~~~）。

A.\dm{java}\hfill B.\dm{class}\hfill C.\dm{exe}\hfill D.\dm{jar}

\begin{tips}
Java源文件的拓展名：\dm{java}

Java源文件编译后拓展名：\dm{class}
\end{tips}

\num 关于继承的描述正确的是（~~~\textcolor[rgb]{1.00,0.00,0.00}{C}~~~）。

A.函数的出口应该尽可能少，最好只有一个出口

B.为了防止程序中的内存泄漏，应该不使用动态内存分配

C.在函数实现中应该少使用全局变量

D.函数的功能应该单一

\begin{tips}
A.函数应为每个逻辑分支提供出口。

B.动态内存分配无法避免，应该及时回收空间和释放指针避免动态内存泄露。

C.为保证封装性，尽量少用全局变量。

D.函数可以根据不同的输入来实现相应的功能（重载）。
\end{tips}

\num 给定一个数组\dm{nums}和一个值\dm{val}，你需要原地移除所有数值等于\dm{val}的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用$O(1)$额外空间的条件下完成。\href{https://leetcode-cn.com/problems/remove-element/\%20--with-chrome-plus-plus\%20--disable-features=RendererCodeIntegrity,FlashDeprecationWarning/} {OJ链接-移除元素}

\begin{tips}
1.边界情况：数组为空时，要返回0。

分析：不考虑顺序，返回的为不含\dm{val}的前边一段，思路：把\dm{val}换到后边去。

2.左指针\dm{lo}指向数组的左边，找\dm{val}，如果没找到\dm{val}，就把这个指针向右移动；

3.右指针\dm{hi}指向数组的右边，\dm{val}就应该位于数组后边，所以如果值是\dm{val}，指针就左移。

4.经过2、3步后，左指针指的是\dm{val}，右指针指的是非\dm{val},将这俩指针对应元素交换。

5.左右指针重合时，数组就遍历完了。

6.左指针的左边一定是不含\dm{val}的，其左边有\dm{lo}个元素，如果此时的左指针对应元素的值时\dm{val}，那就返回\dm{lo}，如果左指针对应元素的值不是\dm{lo}，就返回\dm{lo + 1}。
\end{tips}

\begin{lstlisting}[title = 移除元素]
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length == 0){
            return 0;
        }
        int lo = 0;
        int hi = nums.length - 1;
        int len = 0;
        while(lo < hi){
            if(nums[lo] != val && lo < hi){
                lo++;
            }
            if(nums[hi] == val && lo < hi){
                hi--;
            }
            if(lo < hi){
                int tmp = nums[lo];
                nums[lo] = nums[hi];
                nums[hi] = tmp;
            }
        }
        if(nums[lo] == val){
            return lo;
        }
        return lo + 1;
    }
}
\end{lstlisting}

\num 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。\href{https://leetcode-cn.com/problems/search-insert-position/\%20--with-chrome-plus-plus\%20--disable-features=RendererCodeIntegrity,FlashDeprecationWarning/} {OJ链接-搜索插入位置}

\begin{tips}
有序数组，采用二分查找。

1.找到元素：返回元素的下标。

2.如果数组中没有该元素。退出循环的前一次左指针、右指针、中间指针指向同一元素，若该元素小于目标值，即\dm{nums[mid] < target}，左指针指向中间指针的下一个元素，此时左指针在右指针的右边，退出循环。同时左指针指向的位置也是目标元素要插入的位置。

3.若该元素大于目标值，即\dm{target < nums[mid]},右指针指向中间指针的前一个元素，右指针在左指针的左边，退出循环。左指针的左侧元素必定小于目标值，而左指针指向的元素大于目标值，目标值应该插入到左指针指向的位置处。

4.综上，找到目标值就返回该目标值对应的下标，没找到该目标值就返回左指针指向的位置。
\end{tips}

\begin{lstlisting}[title = 搜索插入位置]
class Solution {
    public int searchInsert(int[] nums, int target) {
        if(nums.length == 0){
            return 0;
        }
        int lo = 0;
        int hi = nums.length - 1;
        int mid = (lo + hi)/2;
        while(lo <= hi){
            mid = (lo + hi)/2;
            if(nums[mid] < target){
                lo = mid + 1;
            }else if(target < nums[mid]){
                hi = mid - 1;
            }else{
                return mid;
            }
        }
        return lo;
    }
}
\end{lstlisting}

\newpage
\section{}%day3
\num 以下代码的循环次数是（~~~\textcolor[rgb]{1.00,0.00,0.00}{D}~~~）。

\begin{lstlisting}[numbers=none]
public class Test {
    public static void main(String[] args) {
        int i = 7;
        do {
            System.out.println(--i);
            --i;
        } while (i != 0);
        System.out.println(i);
    }
}
\end{lstlisting}

A.\dm{0}\hfill B.\dm{1}\hfill C.\dm{7}\hfill D.\dm{无限次}

\begin{jie}
\dm{i}的初始值为奇数，循环中每次减2，退出条件为不等于0，奇数减2永远不会为0，即死循环。
\end{jie}

\num 下列选项中属于面向对象设计方法的主要特征是（~~~\textcolor[rgb]{1.00,0.00,0.00}{A}~~~）。

A.继承\hfill B.自顶向下\hfill C.模块化\hfill D.逐步求精

\begin{tips}
面向对象最主要的几个特征：封装、继承、多态、抽象等。
\end{tips}

\num 下面的方法，当输入为$2$的时候返回值是多少（\hphantom{~~~~~}）。

\begin{lstlisting}[numbers=none]
public static int getValue(int i) {
    int result = 0;
    switch (i) {
        case 1:
            result = result + i;
        case 2:
            result = result + i * 2;
        case 3:
            result = result + i * 3;
    }
    return result;
}
\end{lstlisting}

A.\dm{0}\hfill B.\dm{2}\hfill C.\dm{4}\hfill D.\dm{10}

\num 赎金信。\href{https://leetcode-cn.com/problems/ransom-note/} {OJ链接-赎金信}

\begin{lstlisting}[title=赎金信]
class Solution {
    public boolean canConstruct(String ransomnote, String magazine){

    }
}
\end{lstlisting}

\num 判断一个整数是否是回文数。回文数是指正序（从左到右）和倒叙（从右向左）读都是一样的整数。\href{https://leetcode-cn.com/problems/palindrome-number/\%20--with-chrome-plus-plus\%20--disable-features=RendererCodeIntegrity,FlashDeprecationWarning/} {OJ链接-回文数}

\begin{lstlisting}[title=回文数]
class Solution {
    public boolean isPalindrome(int x){

    }
}
\end{lstlisting}

\newpage
\section{}%day4
\num 下面有关\dm{java final}的基本规则，描述错误的是（\hphantom{~~~~~}）。

A.\dm{final}修饰的类不能被继承

B.\dm{final}修饰的成员变量只允许赋值一次，且只能在类方法赋值

C.\dm{final}修饰的局部变量即为常量，只能赋值一次

D.\dm{final}修饰的方法不允许被子类覆盖

\num 选项中哪一行代码可以替换\dm{//add code here}而不产生编译错误（\hphantom{~~~~~}）。

A.\dm{public abstract void method(int a);}

B.\dm{consInt = constInt + 5;}

C.\dm{public int method;}

D.\dm{public abstract void anotherMethod(){}}

\num 第三行将输出什么（\hphantom{~~~~~}）。

\begin{lstlisting}
public class SwitchTest{
    public static void main(String[] args) {
        System.out.println("value=" + switchit(4));
    }
    public static int switchit(int x) {
        int j = 1;
        switch (x) {
            case 1:j++;
            case 2:j++;
            case 3:j++;
            case 4:j++;
            case 5:j++;
            default:j++;
        }
        return j+x;
    }
}
\end{lstlisting}

A.\dm{value=6;}\hfill B.\dm{value=8;}\hfill C.\dm{value=3;}\hfill D.\dm{value=5;}

\num 给定一个仅包含大小写字母和空格\dm{' '}的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回0。\href{https://leetcode-cn.com/problems/length-of-last-word/} {OJ链接-最后一个单词的长度}

\begin{lstlisting}[title=最后一个单词的长度]
class Solution {
    public int lengthOfLastWord(String s) {

    }
}
\end{lstlisting}

\num
给你两个有序整数数组 \dm{nums1}和\dm{nums2}，请你将\dm{nums2}合并到\dm{nums1}中，使\dm{nums1}成为一个有序数组。\href{https://leetcode-cn.com/problems/merge-sorted-array/} {OJ链接-合并两个有序数组}

\begin{lstlisting}[title=合并两个有序数组]
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

    }
}
\end{lstlisting}

\newpage
\section{}%day5
\num 下列Java程序输出的结果为（\hphantom{~~~~~}）。
\begin{lstlisting}[numbers=none]
public class Example{
    String string = new String("hello");
    char[] chars = {'a','b'};
    public static void main(String args[]){
        Example ex = new Example();
        ex.change(ex.string, ex.ch);
        System.out.print(ex.str + "and");
        System.out.print(ex.ch);
    }
    public void change(String string,char ch[]){
        string = "test ok";
        ch[0] = 'c';
    }
}
\end{lstlisting}

A.\dm{hello and ab} \hfill B.\dm{hello and cb} \hfill C.\dm{hello and a} \hfill D.\dm{test ok and ab}

\num $transient$变量和下面哪一项有关（\hphantom{~~~~~}）。

A.\dm{Cloneable} \hfill B.\dm{Serializable} \hfill C.\dm{Runnable} \hfill D.\dm{Comparable}

\num 已知有下列$Test$类的说明，在该类的$main$方法内，则下列那个语句是正确的（\hphantom{~~~~~}）。
\begin{lstlisting}[numbers=none]
public  class Test {
    private float f = 1.0f;
    int m = 12;
    static int n = 1;
    public static void main (String args[]){
        Test t = new Test();
    }
}
\end{lstlisting}

A.\dm{t.f;}\hfill B.\dm{this.n;} \hfill C.\dm{Test.m;}\hfill D.\dm{Test.f;}

\num 给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回\dm{true} 。如果数组中每个元素都不相同，则返回\dm{false} 。\href{https://leetcode-cn.com/problems/contains-duplicate/} {OJ链接-存在重复元素}

\begin{lstlisting}
class Solution {
    public boolean containsDuplicate(int[] nums) {

    }
}
\end{lstlisting}

\num 你的朋友正在使用键盘输入他的名字$name$。偶尔，在键入字符 $c $时，按键可能会被长按，而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符\dm{typed}。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回\dm{True}。\href{https://leetcode-cn.com/problems/long-pressed-name/} {OJ链接-长按键入}

\begin{lstlisting}
class Solution {
    public boolean containsDuplicate(int[] nums) {

    }
}
\end{lstlisting}

\newpage
\section{}%day6
\num 下面关于Java的垃圾回收机制正确的是（\hphantom{~~~~~}）。

A.当调用\dm{"System.gc()"}来强制回收时，系统会立即回收垃圾

B.垃圾回收不能确定具体的回收时间

C.程序可明确地标识某个局部变量的引用不再被使用

D.程序可以显式地立即释放对象占有的内存

\num 以下会产生信息丢失的类型转换是（\hphantom{~~~~~}）。

A.\dm{float a = 10;}\hfill B.\dm{int a = (int)8846.0 ;}\hfill C.\dm{byte a = 10; int b = a;}\hfill D.\dm{double = 100}

\num 面向对象方法的多态性指的是（\hphantom{~~~~~}）。

A.一个类可以派生出多个特殊类

B.一个对象在不同的运行环境中可以有不同的变体

C.针对一消息，不同的对象可以以适合自身的方式加以响应

D.一个对象可以是由多个其他对象组合而成的

\num 给定一个按非递减顺序排序的整数数组\dm{A}，返回每个数字的平方组成的新数组，要求新数组也按非递减顺序排序。（注意：非递减顺序即递增，要注意原数组里的负数）\href{https://leetcode-cn.com/problems/squares-of-a-sorted-array/} {OJ链接-有序数组的平方}
\begin{lstlisting}[title=有序数组的平方]
class Solution {
    public int[] sortedSquares(int[] nums) {

    }
}
\end{lstlisting}

\num 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。\href{https://leetcode-cn.com/problems/reverse-only-letters/} {OJ链接-仅仅反转字母}
\begin{lstlisting}[title=仅仅反转字母]
class Solution {
    public String reverseOnlyLetters(String S) {

    }
}
\end{lstlisting}
\newpage
\section{}
\num 关于下面程序，哪些描述是正确的（\hphantom{~~~~~}）。

\begin{lstlisting}
public class While {
    public void loop() {
        int x = 10;
        while (x) {
            System.out.print("x minus one is " + (x - 1));
            x -= 1;
        }
    }
}
\end{lstlisting}

A.行1有语法错误\hfill B.行4有语法错误\hfill C.行5有语法错误

D.行6有语法错误\hfill E.行2有语法错误,loop使关键字\hfill D.程序能够正常编译和运行

\num 在各自最优条件下，对$N$个数进行排序，算法复杂度最低的是（\hphantom{~~~~~}）。

A.插入排序\hfill B.快速排序 \hfill C.堆排序\hfill D.归并排序

\num 在\dm{java}中，下列对继承的说法，正确的是（\hphantom{~~~~~}）。

A.子类能继承父类所有的成员 \hfill B.子类继承父类的非私有方法和状态

C.子类只能继承父类的\dm{public}方法和状态 \hfill D.子类只能继承父类的方法

\num 给定一个非负的整数数组\dm{A}，返回一个数组，在该数组中， \dm{A}的所有偶数元素之后跟着所有奇数元素。
\href{https://leetcode-cn.com/problems/sort-array-by-parity/} {OJ链接-按奇偶排序数组}
\begin{lstlisting}[title=按奇偶排序数组]
class Solution {
    public int[] sortArrayByParity(int[] A) {

    }
}
\end{lstlisting}

\num 给定一个整数类型的数组\dm{ nums}，请编写一个能够返回数组 “中心索引” 的方法。

我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\href{https://leetcode-cn.com/problems/find-pivot-index/} {OJ链接-寻找数组的中心索引}
\begin{lstlisting}[title=寻找数组的中心索引]
class Solution {
    public int pivotIndex(int[] nums) {

    }
}
\end{lstlisting}

\newpage
\section{}
\num （\textbf{多选题}）已知\dm{boolean result = false}，则下面哪个选项是合法的（\hphantom{~~~~~}）。

A.\dm{result = 1} \hfill B.\dm{result = true}
\hfill
 C.\dm{if (result != 0) { }} \hfill D.\dm{if (result) { }}

 \num （\textbf{多选题}）下面的\dm{switch}语句中，\dm{x}可以是哪些类型的数据（\hphantom{~~~~~}）。

\begin{lstlisting}[numbers=none]
switch(x){
    default:
    System.out.println("hello");
}
\end{lstlisting}

A.\dm{long}\hfill B.\dm{char}\hfill C.\dm{float}\hfill D.\dm{byte}\hfill E.\dm{double}\hfill F.\dm{Object}

\num （\textbf{多选题}）关于运行时常量池，下列那个说法是正确的（\hphantom{~~~~~}）。

A.运行时常量池大小受栈区大小的影响

B.运行时常量池大小受方法区大小的影响

C.存放了编译时期生成的各种字面量

D.存放编译时期生成的符号引用

\num 给定一个由\textbf{整数}组成的 \textbf{非空} 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。(第一个数字是9或者最后一个是9要考虑进位)
\href{https://leetcode-cn.com/problems/plus-one/} {OJ链接-加一}
\begin{lstlisting}[title=加一]
class Solution {
    public int[] plusOne(int[] digits) {

    }
}
\end{lstlisting}

\num 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。\href{https://leetcode-cn.com/problems/third-maximum-number/} {OJ链接-第三大的数}
\begin{lstlisting}[title=第三大的数]
class Solution {
    public int thirdMax(int[] nums) {

    }
}
\end{lstlisting}
\newpage
\section{}
\num 下列类定义中哪些是合法的抽象类的定义（\hphantom{~~~~~}）。

A.\dm{abstract Animal{abstract void growl();}}

B.\dm{class abstract Animal{abstract void growl();}}

C.\dm{abstract class Animal{abstract void growl();}}

D.\dm{abstract class Animal{abstract void growl(){System.out.println( “growl”);};}}

\num 在\dm{java}中，无论在何处调用，使用静态属性必须以类名做前缀。（\hphantom{~~~~~}）

A.正确\hfill B.错误\hfill\hphantom{B.错误}\hfill\hphantom{B.错误}

\num 哪个关键字可以对对象加互斥锁（\hphantom{~~~~~}）。

A.\dm{synchronized} B.\dm{volatile} C.\dm{serialize} D.\dm{ static}

\num 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。要求时间复杂度$O(n)$,当然也可以选择使用暴力的$O(n^2)$的解法。\href{https://leetcode-cn.com/problems/two-sum/} {OJ链接-两数之和}
\begin{lstlisting}[title=两数之和]
class Solution {
    public int[] twoSum(int[] nums, int target) {

    }
}
\end{lstlisting}

\num 给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 \textbf{非空} 字符串且只包含数字 \dm{1} 和 \dm{0}。\href{https://leetcode-cn.com/problems/add-binary/} {OJ链接-二进制求和}
\begin{lstlisting}[title=二进制求和]
class Solution {
    public String addBinary(String a, String b) {

    }
}
\end{lstlisting}

\newpage
\section{}
\num 一个Java源程序文件中定义几个类和接口，则编译该文件后生成几个以.class为后缀的字节码文件。（\hphantom{~~~~~}）

A.正确\hfill B.错误\hfill\hphantom{B.错误}\hfill\hphantom{B.错误}

\num 要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以（\hphantom{~~~~~}）。

A.让该类不使用任何关键字

B.使用\dm{private} 关键字

C.使用\dm{protected} 关键字

D.使用\dm{void}关键字

\num 判断对错。在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。（\hphantom{~~~~~}）

A.正确\hfill B.错误\hfill\hphantom{B.错误}\hfill\hphantom{B.错误}

\num 字符串转换函数\href{https://leetcode-cn.com/problems/string-to-integer-atoi/} {OJ链接-字符串转换整数atoi}。

请你来实现一个\dm{myAtoi(string s)}函数，使其能将字符串转换成一个 32 位有符号整数（类似\dm{C/C++}中的\dm{atoi}函数）。

函数\dm{myAtoi(string s)}的算法如下：
\begin{itemize}
\itemsep=0pt \parskip=0pt%删除排序列表之间的垂直空白
  \item 读入字符串并丢弃无用的前导空格。
  \item 检查第一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
  \item 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
  \item 将前面步骤读入的这些数字转换为整数（即，"123" $\rightarrow$ 123， "0032" $\rightarrow$32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
  \item 如果整数数超过 32 位有符号整数范围$[−2^{31},  2^{31} − 1]$ ，需要截断这个整数，使其保持在这个范围内。具体来说，小于$−2^{31}$ 的整数应该被固定为$−2^{31}$ ，大于$2^{31} − 1$的整数应该被固定为$2^{31} − 1$。
\item 返回整数作为最终结果。
\end{itemize}

\textbf{注意}：
\begin{itemize}
\itemsep=0pt \parskip=0pt
\item 本题中的空白字符只包括空格字符\dm{' '} 。
\item 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
\end{itemize}

\begin{lstlisting}[title=字符串转换整数atoi]
class Solution {
    public int myAtoi(String s) {

    }
}
\end{lstlisting}

\num 给定一个按照升序排列的整数数组\dm{nums}，和一个目标值 \dm{target}。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值\dm{target}，返回 $[-1, -1]$。
\href{https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/} {OJ链接-在排序数组中查找元素的第一个和最后一个位置}。


\begin{lstlisting}[title=在排序数组中查找元素的第一个和最后一个位置]
class Solution {
    public int[] searchRange(int[] nums, int target) {

    }
}
\end{lstlisting}

\newpage
\section{}
\num 执行下列代码的输出结果是（\hphantom{~~~~~}）。
\begin{lstlisting}
public class Demo{
    public static void main(String args[]){
        int num = 10;
        System.out.println(test(num));
    }
    public static int test(int b){
        try {
            b += 10;
            return b;
        }catch(RuntimeException e){

        }catch(Exception e2){

        }finally{
            b += 10;
            return b;
        }
    }
}
\end{lstlisting}

A.\dm{10}\hfill  B.\dm{20}\hfill C.\dm{30}\hfill D.\dm{40}

\num 下面关于Java package的描述，哪个是正确的（\hphantom{~~~~~}）。

\myroman{1}.包不提供将所有类名分区为更易管理的块的机制。

\myroman{2}.包提供可见性控制机制。

\myroman{3}.	包的一个重要属性是包内定义的所有类都可以通过该包外的代码访问。

\myroman{4}.	声明为包的一部分的类的.class文件可以存储在多个目录中.

A.只有\myroman{1}\hfill B.只有\myroman{2}\hfill C.只有\myroman{3}\hfill D.只有\myroman{4}

\num Java数据库连接库JDBC用到哪种设计模式（\hphantom{~~~~~}）。

A.生成器\hfill B.桥接模式\hfill C.抽象工厂\hfill D.单例模式

\num 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

注意：如果测试用例出现错误：OP这个情况一定注意，这是OP。
\href{https://leetcode-cn.com/problems/valid-palindrome/}{OJ链接-验证回文串}
\begin{lstlisting}[title=验证回文串]
class Solution {
    public boolean isPalindrome(String s) {

    }
}
\end{lstlisting}

\num 给定一组字符，使用\textcolor[rgb]{0.00,1.00,0.25}{原地算法}将其压缩。压缩后的长度必须始终小于或等于原数组长度。数组的每个元素应该是长度为1 的字符（不是\dm{int}整数类型）。在完成原地修改输入数组后，返回数组的新长度。\href{https://leetcode-cn.com/problems/string-compression/}{OJ链接-压缩字符串}
\begin{lstlisting}[title=压缩字符串串]
class Solution {
    public int compress(char[] chars) {

    }
}
\end{lstlisting}
\newpage
\section{}
\num 下列哪个选项是正确计算$42°$（角度）的余弦值（\hphantom{~~~~~}）。

A.\dm{double d=Math.cos(42)}

B.\dm{double d=Math.cosine(42)}

C.\dm{double d=Math.cos(Math.toRadians(42))}

D\dm{double d=Math.cos(Math.toDegrees(42))}

\num \dm{String s = new String("xyz")}创建了几个\dm{String}对象（\hphantom{~~~~~}）。

A.两个或一个都有可能\hfill B.两个\hfill  C.一个\hfill  D.三个

\num 下列代码输出结果为（\hphantom{~~~~~}）。

A.

动物可以移动

狗可以跑和走

狗可以吠叫

B.
动物可以移动 动物可以移动 狗可以吠叫

C.运行错误

D.编译错误

\num 给你一个整数数组\dm{nums}，你需要找出一个\textbf{连续子数组}，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 最短 子数组，并输出它的长度。\href{https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/} {OJ链接-最短无序连续子数组}
\begin{lstlisting}[title=最短无序连续子数组]
class Solution {
    public int findUnsortedSubarray(int[] nums) {

    }
}
\end{lstlisting}

\num 根据\textbf{逆波兰表示法}，求表达式的值。
有效的运算符包括\dm{+},\dm{-},\dm{*},\dm{/} 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\href{https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/} {OJ链接-逆波兰表达式求值}

\textbf{说明}：
\begin{itemize}
\itemsep=0pt \parskip=0pt
  \item 整数除法只保留整数部分。
  \item 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
\end{itemize}

\begin{lstlisting}[title=逆波兰表达式求值]
class Solution {
    public int evalRPN(String[] tokens) {

    }
}
\end{lstlisting}

\newpage
\section{}
\num （\textbf{多选题}）关于\dm{Java}以下描述正确的有（\hphantom{~~~~~}）。

A.\dm{Class}类是\dm{Object}类的超类\hfil  B.\dm{Object}类是一个\dm{final}类

C.\dm{String}类是一个\dm{final}类
\hfill D.\dm{Class}类可以装载其它类

\num （\textbf{多选题}）\dm{Java}中的集合类包括\dm{ArrayList}、\dm{LinkedList} 、\dm{HashMap}等类，下列关于集合类描述正确的是（\hphantom{~~~~~}）。

A.\dm{ArrayList}和\dm{LinkedList}均实现了\dm{List}接口

B.\dm{ArrayList}的访问速度比\dm{LinkedList}快

C.添加和删除元素时，\dm{ArrayList}的表现更佳

D.\dm{HashMap}实现\dm{Map}接口，它允许任何类型的键和值对象，并允许将\dm{null}用作键或值

\num （\textbf{多选题}）关于\dm{equals}和\dm{hashCode}描述正确的是 （\hphantom{~~~~~}）。

A.两个\dm{obj}，如果\dm{equals()}相等，\dm{hashCode()}一定相等（符合代码规范的情况下）

B.两个\dm{obj}，如果\dm{hashCode()}相等，\dm{equals()}不一定相等

C.两个不同的\dm{obj}，\dm{hashCode()}可能相等

D.其他都不对

\num 给你一个整数数组 nums ，数组中的元素\CJKunderdot{互不相同}。返回该数组所有可能的子集（幂集）。
解集\CJKunderdot{不能}包含重复的子集。你可以按\CJKunderdot{任意顺序}返回解集。
\href{https://leetcode-cn.com/problems/subsets/} {OJ链接-子集}

\begin{lstlisting}[title=子集]
class Solution {
    public List<List<Integer>> subsets(int[] nums) {

    }
}
\end{lstlisting}

\num 给定一个整数矩阵，找出最长递增路径的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
\href{https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/} {OJ链接-矩阵中最长递增路径}

\begin{lstlisting}[title=矩阵中最长递增路径]
class Solution {
    public int longestIncreasingPath(int[][] matrix) {

    }
}
\end{lstlisting}

\newpage
\section{}
\num （\textbf{多选题}）下面有关\dm{java}的\dm{instanceof}、 \dm{?}、\dm{&} 、\dm{&&}说法正确的有（\hphantom{~~~~~}）。

A.\dm{instanceof}可用来判断某个实例变量是否属于某种类的类型。

B.\dm{"? :" }三目运算符

C.\dm{&}在逻辑运算中是非短路逻辑与，在位运算中是按位与

D.\dm{&&}逻辑运算：逻辑与

\num （\textbf{多选题}）下面哪个语句是创建数组的正确语句？（\hphantom{~~~~~}）。

A.\dm{float f[][] = new float[6][6]; }

B.\dm{float []f[] = new float[6][6];}

C.\dm{float f[][] = new float[][6];}

D.\dm{float [][]f = new float[6][6];}

E.\dm{float [][]f = new float[6][];}

\num 下列类在多重\dm{catch}中同时出现时，哪一个异常类应最后一个列出（\hphantom{~~~~~}）。

A.\dm{ArithmeticException }\hfill
B.\dm{NumberFormatException}\hfill
C.\dm{Exception}\hfill
D.\dm{ArrayIndexOutOfBoundException}

\num 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\href{https://leetcode-cn.com/problems/binary-tree-right-side-view/} {OJ链接-二叉树的右视图}

\begin{lstlisting}[title=二叉树的右视图]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {

    }
}
\end{lstlisting}

\num 公交路线。\href{https://leetcode-cn.com/problems/bus-routes/} {OJ链接-公交路线}

我们有一系列公交路线。每一条路线\dm{routes[i]}上都有一辆公交车在上面循环行驶。例如，有一条路线\\ \dm{routes[0] = [1, 5, 7]}，表示第一辆 (下标为0) 公交车会一直按照 $1\rightarrow 5\rightarrow 7\rightarrow 1\rightarrow 5\rightarrow 7\rightarrow 1\rightarrow \ldots $的车站路线行驶。

假设我们从$S$车站开始（初始时不在公交车上），要去往$T$站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回$1-$表示不可能到达终点车站。

\begin{lstlisting}[title=公交路线]
class Solution {
    public int numBusesToDestination(int[][] routes, int S, int T) {

    }
}
\end{lstlisting}

\num 通配符匹配。\href{https://leetcode-cn.com/problems/wildcard-matching/} {OJ链接-通配符匹配}

给定一个字符串($s$)和一个字符模式 ($p$)，实现一个支持\dm{ '?'} 和\dm{'*'}的通配符匹配。
\begin{itemize}
\itemsep=0pt \parskip=0pt
\item \dm{'?'}可以匹配任何单个字符。
\item \dm{'*'}可以匹配任意字符串（包括空字符串）。
\end{itemize}
两个字符串完全匹配才算匹配成功。

\textbf{说明}:
\begin{itemize}
\itemsep=0pt \parskip=0pt
\item $s$可能为空，且只包含从 \dm{a-z}的小写字母。
\item $s$可能为空，且只包含从 \dm{a-z}的小写字母，以及字符\dm{?}和\dm{*}。
\end{itemize}
\begin{lstlisting}[title=通配符匹配]
class Solution {
    public boolean isMatch(String s, String p) {

    }
}
\end{lstlisting}
\end{document}


